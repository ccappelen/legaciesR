% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_contours.R
\name{get_contours}
\alias{get_contours}
\title{Get Contour Polygons Across Groups}
\usage{
get_contours(
  shp,
  grp_id,
  by_period = FALSE,
  interval = NULL,
  period_id,
  nmap_threshold = 5,
  invalid_geom = c("stop", "fix", "exclude"),
  smoothing = TRUE,
  returnList = FALSE,
  progress = TRUE,
  parallel = NULL,
  ncores,
  ...
)
}
\arguments{
\item{shp}{An sf dataframe containing all geometries (polygons).}

\item{grp_id}{Name of the grouping variable.}

\item{by_period}{Logical, indicating if shapes should be divided into groups by time in addition to IDs.
Default is \code{FALSE.}}

\item{interval}{Scalar or vector indicating the intervals to group by. If \code{NULL} (default), the
intervals will automatically be set to 20 (years) and include the full range (i.e. \code{seq(min, max, 20)}).
For user specification, the value can be either a scalar, indicating the length of intervals
(in which case the full range is used), or a vector specifying the exact breaks, including both the
start of the first interval and end of the last interval.}

\item{period_id}{Name of the period variable to be used for time grouping.
This argument is necessary if \code{by_period} is \code{TRUE.}}

\item{nmap_threshold}{Integer, indicating the number of shapes requires within each group. Default is 5.}

\item{invalid_geom}{Character, how to handle invalid geometries. If \code{"stop"}, returns an error
if there are invalid geometries; if \code{"exclude"}, invalid geometries will be removed before
calculating contours; if \code{"fix"}, invalid geometries will be rebuilt using \link{fix_invalid}.
It is recommended to check for invalid geometries and run \link{fix_invalid} separately.}

\item{smoothing}{Logical, whether to apply smoothing after polygonizing the raster. Default is \code{TRUE}.}

\item{returnList}{Logical, whether to return a list of geometries by group.
Default is to return an sf dataframe containing all geometries.}

\item{progress}{Logical, whether to show a progress bar.}

\item{parallel}{Logical, whether to use parallel processing with \code{ncores} number of cores.
See details below.}

\item{ncores}{Integer, the number of cores to use for parallel processing. Default is all available cores minus 1.}

\item{...}{Additional arguments passed to \link{contour_polygons}.}
}
\value{
Returns either an sf dataframe (default) or a list of sf dataframes (one list item per group).
}
\description{
This function creates contour polygons across multiple groups, either by group alone or
in combination with a time column.
}
\section{Support for parallel processing}{

Parallel processing is is implemented using the \link[future:future]{future::future} framework. There are two ways
of running jobs in parallel: \code{multicore} which uses 'forking' to run multiple jobs in parallel with
shared memory and \code{multisession} which launches a set of background R sessions. 'Forking' can be faster
than multisession because of the larger overhead associated with copying the active environment to
each background R session (whereas forking processes shares memory). However, 'forking' is not
supported on Windows platforms and is considered unstable when running from within RStudio
(on both Windows and Unix systems such as MacOS). The function will automatically determine
whether \code{multicore} is supported by the platform and choose the appropriate plan.

The greater overhead associated with \code{multisession} is primarily during the first parallel
run in a given R session (since the background R sessions stays available for additional
parallel jobs). It is possible to define a \code{\link[future:plan]{future::plan()}} in the global environment,
which will minimize overhead in subsequent parallel jobs (apart from the first). The function will
automatically detect if a \code{multisession} plan has been set globally and, thus, will not close
background sessions after running.
}

